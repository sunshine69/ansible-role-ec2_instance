# The ami dict is the result of role lookup_ec2_ami
- include_role:
    name: lookup_ec2_ami

- fail:
    msg: |
      Can not find the base image. Ensure your tags are correct or set ami_image directly
      Your search tag is: {{ ami_search_tags|default('') }}
      Your ami_image is: {{ ami_image|default('') }}
  when: not ami

- name: set instance search filters
  set_fact:
    ec2_instance_search_filters: "{{ ec2_instance_search_filters|default({'instance-state-name': ['running', 'stopped']})|combine({ 'tag:' + item.key: item.value }) }}"
  with_dict: "{{ ec2_instance_search_tags }}"
  when: item.value != ""

- debug:
    var: ec2_instance_search_filters
    verbosity: 2

- name: Get any existing instances that require termination
  ec2_remote_facts:
    region: "{{ region }}"
    profile: "{{ profile|default(omit) }}"
    filters: "{{ ec2_instance_search_filters }}"
  register: ec2_instances

- name: Terminate undesired existing instances
  ec2:
    region: "{{ region }}"
    profile: "{{ profile|default(omit) }}"
    instance_ids: "{{ item.id }}"
    state: absent
  with_items: "{{ ec2_instances.instances }}"
  when: ec2_instance_termination|bool

- block:
  - name: remove the ephemeral key if exists
    file:
      path: "~/.ssh/{{ ec2_key_pair }}"
      state: absent

  - name: create ephemeral ssh key
    command: ssh-keygen -b 2048 -N '' -f ~/.ssh/{{ ec2_key_pair }}

  - name: upload key to AWS
    ec2_key:
      region: "{{ region }}"
      profile: "{{ profile|default(omit) }}"
      key_material: "{{ lookup('file', '~/.ssh/{{ ec2_key_pair }}.pub') }}"
      name: "{{ ec2_key_pair }}"
      force: yes
  when: generate_ephemeral_key|bool

- debug:
    var: ec2_subnet_search_filter
    verbosity: 2

- block:
  - name: Get subnets ids based on ec2_subnet_search_filter
    ec2_vpc_subnet_facts:
      region: "{{ region }}"
      profile: "{{ profile|default(omit) }}"
      filters: "{{ ec2_subnet_search_filter }}"
    register: ami_build_subnets

  - name: Set instance build tags
    set_fact:
    args:
      ec2_instance_build_tags: "{{ ec2_instance_build_tags|default({})|combine({item.key: item.value}) }}"
    with_dict: "{{ ec2_instance_tags }}"
    when: item.value != ""

  - debug:
      msg: "Instance profile: {{ec2_instance_profile|default('None')}}"
      verbosity: 2

  - debug:
      msg: "ec2_instance_build_tags: {{ ec2_instance_build_tags }}"
      verbosity: 2

  - name: Launch EC2 instance
    ec2:
      region: "{{ region }}"
      profile: "{{ profile|default(omit) }}"
      key_name: "{{ ec2_key_pair }}"
      group: "{{ ec2_instance_security_groups }}"
      instance_type: "{{ ec2_instance_type }}"
      monitoring: "{{ ec2_instance_monitoring }}"
      user_data: "{{ ec2_instance_user_data|default(lookup('file', 'userdata.sh')) }}"
      image: "{{ ami.ami_id }}"
      wait: yes
      volumes: "{{ ec2_volumes | default(default_volumes)}}"
      vpc_subnet_id: "{{ ami_build_subnets.subnets[0].id }}"
      assign_public_ip: "{{ ec2_instance_is_public }}"
      instance_tags: "{{ ec2_instance_build_tags }}"
      instance_profile_name: "{{ ec2_instance_profile|default(omit) }}"
      private_ip: "{{ ec2_instance_private_ip_address|default(omit) }}"
    register: ec2_build_instance

  - name: set ec2_instance fact
    set_fact:
      ec2_instance: "{{ ec2_build_instance.instances[0] }}"

  - name: "Auto allocate eip if variable ec2_eip has the value of 'auto'"
    ec2_eip:
      profile: "{{ profile|default(omit) }}"
      region: "{{ region }}"
      reuse_existing_ip_allowed: yes
      state: present
    register: eip_auto
    when: ec2_eip is defined and ec2_eip == 'auto'

  - name: Set fact to set new allocated ec2_eip
    set_fact:
      ec2_eip: "{{ eip_auto.public_ip }}"
    when: ec2_eip is defined and ec2_eip == 'auto'

  - name: set ec2 EIP if available
    ec2_eip:
      region: "{{ region }}"
      profile: "{{ profile|default(omit) }}"
      device_id: "{{ ec2_instance.id }}"
      public_ip: "{{ ec2_eip }}"
      reuse_existing_ip_allowed: yes
      release_on_disassociation: "{{ ec2_eip_release_on_disassociation|default(false) }}"
      in_vpc: yes
    when: ec2_eip is defined

  - name: find bastion host
    ec2_remote_facts:
      region: "{{ region }}"
      profile: "{{ profile|default(omit) }}"
      filters:
        "tag:Application": bastion
        instance-state-name: "running"
    register: bastion_host
    when: not ssh_via_public and not is_window

  - name: Wait for ssh to become available
    wait_for:
      port: "{{ ssh_port }}"
      host: "{{ ec2_eip|default(ec2_instance.public_ip) if ssh_via_public else ec2_instance.private_ip }}"
      search_regex: OpenSSH
      delay: 1
    # note that `delegate_to: localhost` below will work over the `local` connection - sshd is not required
    delegate_to: "{{ bastion_host.instances[0].public_ip_address if not bastion_host|skipped else 'localhost' }}"
    when: not is_window

  - name: Wait for winrm service to become available
    wait_for:
      port: "{{ winrm_port }}"
      host: "{{ ec2_eip|default(ec2_instance.public_ip) if winrm_via_public else ec2_instance.private_ip }}"
      delay: 1
      timeout: 600
    when: is_window

  - name: even after wait_for we still need to pause
    pause:
      seconds: 10
  when: not ec2_instances.instances or ec2_instance_termination|bool

- name: set ec2_instance fact
  set_fact:
    ec2_instance: "{{ ec2_instances.instances[0] }}"
  when: ec2_build_instance|skipped

- name: set ec2_instance_address fact
  set_fact:
    ec2_instance_address: "{{ ec2_eip|default(ec2_instance.public_ip_address)|default(ec2_instance.public_ip) if ssh_via_public else ec2_instance.private_ip_address|default(ec2_instance.private_ip) }}"

- name: set ec2_instance_public_address fact
  set_fact:
    ec2_instance_public_address: "{{ ec2_eip|default(ec2_instance.public_ip_address)|default(ec2_instance.public_ip) if ec2_instance_is_public else '' }}"

- add_host:
    hostname: "{{ ec2_instance_address }}"
    public_ip: "{{ ec2_instance_public_address|default('') }}"
    groups: "{{ ec2_launch_groups }}"
    ansible_ssh_private_key_file: "~/.ssh/{{ ec2_key_pair }}"
    inventory_dir: "{{ inventory_dir }}"  # workaround for https://github.com/ansible/ansible/issues/30901
    ansible_user: "{{ ec2_instance_user|default(omit) }}"
  changed_when: false

- block:
    - raw: which python2 python
      register: finding_python
      changed_when: False
      failed_when: False
      delegate_to: "{{ ec2_instance_address }}"

    - name: Install python-minimal
      raw: apt-get update && apt-get -y install python-minimal
      become: yes
      delegate_to: "{{ ec2_instance_address }}"
      when: not finding_python.stdout_lines

    - name: Wait for cloud-init to complete
      wait_for:
        path: /run/cloud-init/result.json
      delegate_to: "{{ ec2_instance_address }}"
      become: yes

    # Update host to set ansible_python_interpreter back
    - add_host:
        hostname: "{{ ec2_instance_address }}"
        groups: "{{ ec2_launch_groups }}"
        ansible_ssh_private_key_file: "~/.ssh/{{ ec2_key_pair }}"
        ansible_python_interpreter: /usr/bin/python
        ec2_instance: "{{ ec2_instance }}"
      changed_when: false
  when: not is_window

- block:
    - name: Add to window group
      add_host:
        hostname: "{{ ec2_instance_address }}"
        groups: "{{ ec2_launch_groups }},windows"
        ec2_instance: "{{ ec2_instance }}"
      changed_when: false

  when: is_window

- debug:
    var: ec2_instance
    verbosity: 2
